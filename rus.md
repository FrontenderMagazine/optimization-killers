# Убийцы оптимизации

## Введение

В этой статье я расскажу про то, как избегать написания кода, который будет работать
значительно хуже, чем вы думаете. В частности, покажу антипаттерны, мешающие V8 (также
относится к Node.JS, опере и хромиумам) оптимизировать ваши функции.

### Предыстория о V8

В движке V8 нет интерпретаторов, но существует два типа компиляторов: общий и
оптимизирующий. Это приводит к тому, что JavaScript всегда компилируется и запускается
точно также как и машинный код. Означает ли, что этот код быстрый? Нет. Само по себе
компилирование не убыстряет код. Оно отменяет пенальти интерпретатора, но код сам по
себе будет ещё медленным, пока не дойдёт дело до оптимизации.

Например, в обычном компиляторе выражение `a + b` станет похожим на что-то такое:

    mov eax, a
    mov ebx, b
    call RuntimeAdd

Другими словами этот код будет каждый раз вызывать функцию. С другой стороны если `a`
и `b` всегда будут целыми, то скомпилированный код будет другим:

    mov eax, a
    mov ebx, b
    add eax, ebx

И новая версия кода будет выполняться в разы быстрее, чем вызов сложной javascript-
функции.

Общими словами, сырой машинный код вы получаете после общего компилятора, затем
результат передаётся оптимизирующему компилятору. Код на выходе от оптимизирующего
компилятора с легкостью может быть, скажем, в 100 раз быстрее, чем после
первоначальной компиляции. Но здесь есть подводный камень, вы не можете писать какой
угодно JavaScript-код и быть уверены, что он соптимизируется. Существует множество
паттернов, некоторые даже основополагающие, при использовании которых в JS
оптимизирующий компилятор будет отказываться трогать ваш код (и код в результате
вываливается необработанным как есть).

Важно заметить, что эти паттерны обладают катастрофически эффектом для всей функции в
которой содержатся. Код оптимизируется только по одной функцией в каждый момент
времени без знания о том, что делает остальной код (если только этот код заинлайнен в
текущую оптимизируемую функцию).

Эта инструкция покрывает большинство антипаттернов вызывающих «деоптимизационный ад».
Со временем антипаттерны могут меняться и предложенные пути решения могут стать
необязательными, когда оптимизирующий компилятор станет умнее и научится распозновать
антипаттерны.


## Темы

1. [Инструменты](#1-tooling)
2. [Неподдерживаемый синтаксис](#2-unsupported-syntax)
3. [Обработка `arguments`](#3-managing-arguments)
4. [Switch-case](#4-switch-case)
5. [For-in](#5-for-in)


## 1. Инструменты

Вы должны уметь использовать node.js с несколькими включёнными флагами V8, чтобы
убедиться как антипаттерны влияют на оптимизацию. В общих чертах, вы создаёте, функцию
содержащую паттерн, вызываете её всеми возможными способами, вызываете внутренние V8
методы для оптимизации и вникаете в результат.

_test.js:_

    // Функция с антипаттерном для исследования (выражение `with`)
    function containsWith() {
        return 3;
        with({}) {}
    }
    
    function printStatus(fn) {
        switch(%GetOptimizationStatus(fn)) {
            case 1: console.log("Функция оптимизирована"); break;
            case 2: console.log("Функция не оптимизирована"); break;
            case 3: console.log("Функция всегда оптимизируема"); break;
            case 3: console.log("Функция никогда не оптимизируема"); break;
            case 6: console.log("Функция возможно деоптимизирована"); break;
        }
    }
    
    // вызовите функцию
    containsWith();
    
    %OptimizeFunctionOnNextCall(containsWith);
    // Следующий вызов
    containsWith();
    
    // Проверка
    printStatus(containsWith);

Запустите файл:

    $ node --trace_opt --trace_deopt --allow-natives-syntax test.js
    Функция не оптимизирована

Чтобы проверить правильность работы, закомментируйте выражение `with` и вызовите
скрипт ещё раз:

    $ node --trace_opt --trace_deopt --allow-natives-syntax test.js
    [optimizing 000003FFCBF74231 <JS Function containsWith (SharedFunctionInfo 00000000FE1389E1)> - took 0.345, 0.042, 0.010 ms]
    Функция оптимизирована

Важно использовать этот инструмент для подтвеждения того, что обходные решения
работают и необходимы.


## 2. Неподдерживаемый синтаксис

Некоторые конструкции не поддерживаются оптимизирующим компилятором, что приводит к
тому, что функция в которой используется такой синтаксис становится не способной к
оптимизации.

**Очень важно отметить**, что даже если конструкция никогда не будет выполняться, она
одним только фактом своего существования выключает оптимизацию для всей функции.

К примеру этот хак не спасёт положения:

    if (DEVELOPMENT) {
        debugger;
    }

Код выше накажет всю вмещающую себя функцию, даже если выражение `debugger;` никогда
не будет выполняться.

На данный момент не оптимизируются:

- Генераторы
- Функции, содержащие выражение `for-of`
- Функции, содержащие выражение `try-catch`
- Функции, содержащие выражение `try-finally`
- Функции, содержащие присваивание с помощью `let`
- Функции, содержащие присваивание с помощью `const`
- Функции, содержащие литералы объекта с использованием `__proto__`, `get` или `set` конструкций.

Никогда не оптимизируются:

- Функции, содержащие выражение `debugger`
- Функции, непосредственно вызывающие `eval()`
- Функции, содержащие выражение `with`

Чтобы было ясно насчёт последних утверждений: вся функция недоступна для оптимизации,
если сделать что-нибудь подобное:

    function containsObjectLiteralWithProto() {
        return {__proto__: 3};
    }

    function containsObjectLiteralWithGetter() {
        return {
            get prop() {
                return 3;
            }
        };
    }

    function containsObjectLiteralWithSetter() {
        return {
            set prop(val) {
                this.val = val;
            }
        };
    }

Прямое использование `eval` и `with` заслуживает отдельного внимание, так как их
использование влечёт за собой применение динамической области видимости относительно
всего, к чему они относятся, поэтому есть возможность при оптимизации сломать
множество остальных функций, так как невозможно наверняка знать какая переменная
за что отвечает.

**Обходные решения**

Некоторые из упомянутых выше выражений сложно избегать в конечном коде, например
конструкции `try-finally` и `try-catch`. Чтобы использовать эти конструкции с
минимальным пенальти, они должны быть изолированы в минимальной функции, чтобы не
затронуть основной код:

    var errorObject = {value: null};
    function tryCatch(fn, ctx, args) {
        try {
            return fn.apply(ctx, args);
        } catch(e) {
            errorObject.value = e;
            return errorObject;
        }
    }

    var result = tryCatch(mightThrow, void 0, [1,2,3]);
    // Однозначно выяснем произошло ли исключение
    if (result === errorObject) {
        var error = errorObject.value;
    } else {
        // результат и есть возвращённое значение
    }

## 3. Обработка `arguments`

Существует несколько способов использовать `arguments` так, чтобы недопустить
оптимизацию функции. Каждый должен предельно осторожен с `arguments`.

#### 3.1. Переопределение передаваемого параметра вместе с упоминанием `arguments` в теле функции.

    function defaultArgsReassign(a, b) {
        if (arguments.length < 2) b = 5;
    }

**Обходное решение:** сохранить параметр в новую переменную:

    function reAssignParam(a, b_) {
        var b = b_;
        // b в отличие от b_, может быть безопасно переприсвоено
        if (arguments.length < 2) b = 5;
    }

Если это единственнная причина использования `arguments`, то часто можно заменить на
проверку на `undefined`:

    function reAssignParam(a, b) {
        if (b === void 0) b = 5;
    }

Тем не менее если есть вероятность, что функция позже будет использовать `arguments`,
то при поддержке достаточно просто забыть убрать переприсваивание в этом месте,
поэтому учитывайте эти два фактора при разработке.

#### 3.2. Утечка arguments:

    function leaksArguments1() {
        return arguments;
    }
    
    function leaksArguments2() {
        var args = [].slice.call(arguments);
    }
    
    function leaksArguments3() {
        var a = arguments;
        return function() {
            return a;
        };
    }

Объект `arguments` не должен никуда передаваться или «утекать» как либо ещё.

**Обходное решение:** для безопасной передачи `arguments` создайте новый массив:

    function doesntLeakArguments() {
        // .length просто ещё одно число, поэтому
        // весь объект `arguments` не утекает
        var args = new Array(arguments.length);
        for(var i = 0; i < args.length; ++i) {
            // i всегда валидный индекс для объекта `arguments`
            args[i] = arguments[i];
        }
        return args;
    }

Это решение слишком большое и громоздкое и стоит несколько раз подумать, стоит ли игра
свеч. Как вы видите оптимизация всегда требует большого количества кода, а значит и
читаемость убивается на корню.

С другой стороны, если вас есть этап сборки, желаемый эффект можно достичь с помощью
макроса, что не потребует использования карт кода и позволит исходному коду оставаться
валидным javascript-кодом:

    function doesntLeakArguments() {
        INLINE_SLICE(args, arguments);
        return args;
    }

Эта техника используется в bluebird и в результате на этапе сборки код разворачивается
в такой:

    function doesntLeakArguments() {
        var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
        return args;
    }

#### 3.3. Присваивание аргументам:

Это может случиться при небрежном написании кода:

    function assignToArguments() {
        arguments = 3;
        return arguments;
    }

**Обходное решение**: нет нужды в таком идиотском коде. В любом случае такой код в
строгом режиме будет вызывать исключение.

#### Как же безопасно использовать `arguments`?

Используйте только

- `arguments.length`
- `arguments[i]` **при этом `i` должен быть валидным целым индесом для `arguments`**
- Никогда не используйте `arguments` напрямую без `.length` или `[i]` (ТОЛЬКО `x.apply(y, arguments)` МОЖНО использовать, ничего из оставшегося нельзя, например нальзя использовать `.slice`. `Function#apply` особенный случай).

Стоит заметить, что все страшилки про то, что любое упоминание `arguments` приводит к
выделению дополнительной памяти остаются лишь страшилками, пока в пользуетесь
вышеупомянутыми безопасными способами.

